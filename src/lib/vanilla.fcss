
@function ease(f:number):number {
    return Math.sin(f);
}


@function ease(f:<number>):<number> sin(var(f));
@def 1marg:<length> 2px;
@def sin(f:<number>, r:<length>):<length> js(r*Math.sin(f));

@length px 12pt;
@length px js(1);
@dimension <mass>;

@js {

}

@if x < 14 {
 
}

@property font-size: fits(s:selector) max(m:length) {
  font-size: js(
     /* some magic */
     return x;
  )
}

@number x = 
@color asdf linear();

@easing gobrnf(Asdf) {
  
}


body {
  background-color: js(getBgColor()) ! transition(3s ease);
  transition: 
}

/* <3 */
@shorthand background: 
    background-image: <'background-image'> || 
    background-attachment: <'background-attachment'> ||
    background-color: <background-color>;
<'background'> := ...

@shorthand background: vibrating {
    background-image: ...;
    transition: --- ;
}

@def error:<'border'> dotted 1px red;
@def hover:<'border'> dotted 1px red;

@def [background-image: <'background-image'...] : <'background'>

@def cplx(<number> <number>):<complex>;
@def [x:<number>]:<complex> cplx(x 0);
@dimension j:<complex> cplx(0 j);
@def [x:<dimension(j)>]:<complex> cplx(0 calc(x / j)); /* ???? */
@def @dim(x:<number> j):<complex> 0 var(x);
@def im(cplx(x:<number> y:<number>)) x;
@def re(cplx(x:<number> y:<number>)) y;
@def [x:<complex> '+' y:<complex>]:<-funcssri-expr-addition> 
    cplx(calc(fst(var(x)) + fst(var(y))) calc(snd(var(x)) + snd(var(y)));

@def cplx(<num> <num>):<complex>;
@def [x:<num>]:<complex> cplx(x 0);
@dimension j:<complex> cplx(0 j);
@def [x:<dimension(j)>]:<complex> cplx(0 calc(x / j)); /* ???? */
@def @dim(x:<num> j):<complex> 0 var(x);
@def im(cplx(x:<num> y:<num>)) x;
@def re(cplx(x:<num> y:<num>)) y;
@def [x:<complex> '+' y:<complex>]:<-funcssri-expr-addition> 
    cplx(calc(fst(var(x)) + fst(var(y))) calc(snd(var(x)) + snd(var(y)));

@def cplx(num num):complex;
@def [x:num]:complex cplx(x 0);
@dimension j:complex cplx(0 j);
@def [x:dimension(j)]:complex cplx(0 calc(x / j)); /* ???? */
@def @dim(x:num j):complex 0 var(x);
@def im(cplx(x:num y:num)):num x;
@def re(cplx(x:num y:num)):num y;
@def [x:complex '+' y:complex]:-funcssri-expr-addition 
    cplx(calc(fst(var(x)) + fst(var(y))) calc(snd(var(x)) + snd(var(y)));


@color sky;

@length vw js(getPageWidth()/100);

@color telekom #ffee00;
@color beige   #aabbcc;

@number x() {
  return getX();
}

@length menuSize() {
  return getMenuSize();
}



@color rgb(<number>, <number>, <number>);

@def rgb(r:<percentage>,g:<percentage>,b:<percentage>):<color> {
  return [r*255, g*255, b*255];
}
@export x:<color> rgb(js(x[0]), js(x[1]), js(x[2]));
@export

@def -css-rgb()

@def yellow:<color>;
@def bold:<'font-weight'>;
@def 700:<'font-weight'>;
@def 400:<'font-weight'>;
@prop font-weight: 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | bold | normal;
@def rgb(<percentage>,<percentage>,<percentage>):<color> in-js([255*r, 255*g, 255*b]);
@def <color>:<'background-color'>;
@def transparent:<color> rgba(0,0,0,0);
@def sin(x:<number>):<number> js(Math.sin(x));
@def sin(x:<number>):<number> {
  return Math.sin(x);
}
x:number
@def -funcss-number(x:<number>):<number> x;
@def asdf(x:<number>):<number> sin(x);
@def x:<number>
@def [x:<js-value>]:<color> rgba(js-number(x[0]),js-number(x[1]),js-number(x[2]),1);
@def [x:<js-value>]:<color> {
  return "#" + intToStr(adsflkjasdf);
}

@number js(x

/* nem tudom, hogy kell-e ez */



az van, hogy milyen kódrészletek vannak
I. value
  5
  hello
  "asdf"
  asdf(hello)
  hello "world"
  5px
  100%
  /

II. type
  <number>
  <integer>
  hello
  on | off
  <length> || <size>
  rgb(<number>,<number>,<number>)

III. js
  4
  if (a) { console.log(5+5); }
  return x;

IV. js expr
  4,5?6:7

V. selector
  :asdf(3)

VI. an+b
  -n

Ha azt szeretnénk, hogy a definícióban is típus legyen?

@def típus1 : típus2 = érték;
@típus2 típus1 = érték;

Konkrétan:

@def <number> : length ...;
@def f()

Ahá! ne lehessen a : után megadni típust. Csak típusnevet. Ha valaki összetett típust szeretne, akkor muszáj legyen definiálni:

@type boolean = true | false;
@type 'border' = <'border-width'> | <'border-color'> | <'border-type'>;

Itt a teljes VDS használható.

@def f(x:number)

Ekkor

x:[...]

nem érvényes.

@def hello:'border' = 1px solid black;
@'border' hello = 1px solid black;
@property border: hello {
    border: 1px solid black;
}

VII. megengedett definíicós atomok
  x:string
  x:*
  $x
  x
  f()
  f(hello)



Az = után a szemantikus függvényt adjuk meg.
Vagy {} van és JS blokk.

@def $hello:number = js(5);

@def ,,//,x:number,,/


Mi van, ha nincs megadva (inferált) a típus?

x = 7;
@number x = 7

Ezután ha
opacity: x;

vagy border-width: x;

És mi van, ha
@length solid = 9px;
border: solid;
melyiket fogja megtalálni? Mindkettőt, és figyel, hogy ne lehessen kétértelmű? az jó...

Olyan hardcore típusrendszere legyen, mint a Haskell-nek? Vagy olyan, mint az Agdának? :)




Mivan???

Tehát

@property ident1: definable1 {
}


A definable miben különbözik a vds-től?
Mindkettőben van
  keyword
  multipl
VDS-ben van csak
  
DEF-ben van csak
  
