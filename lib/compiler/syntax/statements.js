// Generated by CoffeeScript 1.9.1
(function() {
  var Parser, SS, k, ref, v;

  Parser = require("./parser");

  SS = require("./ss_nodes");

  SS.Statement = (function() {
    function Statement(value1) {
      this.value = value1;
    }

    Statement.prototype.toString = function() {
      return this.value + ";";
    };

    return Statement;

  })();

  SS.StatementList = (function() {
    function StatementList() {}

    StatementList.prototype = [];

    StatementList.prototype.toString = function() {
      return this.join("\n");
    };

    return StatementList;

  })();

  ref = {
    parse_list_of_statements: function(tokens) {
      this.init(tokens);
      return this.consume_list_of_statements();
    },
    consume_list_of_statements: function() {
      var list, result, statement, temp_stream;
      result = new SS.StatementList;
      while (true) {
        this.consume_next();
        switch (false) {
          case !(this.current instanceof SS.WhitespaceToken || this.current instanceof SS.SemicolonToken):
            "do nothing";
            break;
          case !(this.current instanceof SS.EOFToken):
            return result;
          case !(this.current instanceof SS.AtKeywordToken):
            result.push(this.consume_at_rule());
            break;
          default:
            list = [this.current];
            this.consume_next();
            while (!(this.current instanceof SS.SemicolonToken || this.current instanceof SS.EOFToken)) {
              list.push(this.current);
              this.consume_next();
            }
            temp_stream = this.stream;
            try {
              this.stream = list;
              this.consume_next();
              statement = this.consume_a_statement();
            } finally {
              this.stream = temp_stream;
            }
            if (statement != null) {
              result.push(statement);
            }
        }
      }
    },
    consume_a_statement: function() {
      var value;
      value = new SS.ComponentValueList;
      value.push(this.current);
      this.consume_next();
      while (!(this.current instanceof SS.EOFToken)) {
        this.reconsume_current();
        value.push(this.consume_component_value());
        this.consume_next();
      }
      return new SS.Statement(value, false);
    }
  };
  for (k in ref) {
    v = ref[k];
    Parser.constructor.prototype[k] = v;
  }

}).call(this);
