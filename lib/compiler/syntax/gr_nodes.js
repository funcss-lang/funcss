// Generated by CoffeeScript 1.9.1
(function() {
  var Cons, GR, Id, Opt, Or, Parser, SS, Snd, Swap, Tokenizer, Whitespace, assert, max,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  assert = require("../helpers/assert");

  Tokenizer = require("./tokenizer");

  Parser = require("./parser");

  SS = require("./ss_nodes");

  GR = exports;

  GR.Stream = (function() {
    function Stream(items, eof1) {
      var t;
      this.eof = eof1;
      (this.items = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = items.length; j < len; j++) {
          t = items[j];
          results.push(t);
        }
        return results;
      })()).push(new SS.EOFToken(this.eof));
      this.position = 0;
    }

    Stream.prototype.consume_next = function() {
      return this.current = this.items[this.position++];
    };

    Stream.prototype.next = function() {
      return this.items[this.position];
    };

    Stream.prototype.reconsume_current = function() {
      return this.items.unshift(this.current);
    };

    Stream.prototype.backtrack = function(options) {
      var e, p;
      try {
        p = this.position;
        return options["try"]();
      } catch (_error) {
        e = _error;
        if (e instanceof GR.NoMatch) {
          this.position = p;
          return options.fallback(e);
        } else {
          throw e;
        }
      }
    };

    Stream.prototype.optionalWhitespace = function() {
      while (this.next() instanceof SS.WhitespaceToken) {
        this.consume_next();
      }
    };

    Stream.prototype.noMatchNext = function(expected) {
      throw new GR.NoMatch(expected, this.next(), this, this.position);
    };

    Stream.prototype.toStringUntil = function(position) {
      var t;
      return ((function() {
        var j, len, ref, results;
        ref = this.items.slice(0, position);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          t = ref[j];
          results.push(t);
        }
        return results;
      }).call(this)).join("");
    };

    Stream.prototype.toStringFrom = function(position) {
      var t;
      return ((function() {
        var j, len, ref, results;
        ref = this.items.slice(position);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          t = ref[j];
          results.push(t);
        }
        return results;
      }).call(this)).join("");
    };

    return Stream;

  })();

  GR.NoMatch = (function(superClass) {
    extend(NoMatch, superClass);

    function NoMatch(expected1, found, stream, position1) {
      this.expected = expected1;
      this.found = found;
      this.stream = stream;
      this.position = position1;
      if (this.found instanceof SS.SimpleBlock) {
        this.found = this.found.token;
      } else if (this.found instanceof SS.Function) {
        this.found = new SS.FunctionToken(this.found.name);
      }
      this.name = "No match";
      this.message = typeof message !== "undefined" && message !== null ? message : this.expected + " expected but '" + this.found + "' found";
      this.stack = this.message + "\n" + (this.stackTrace());
    }

    NoMatch.prototype.toString = function() {
      return this.name + ": " + this.message;
    };

    NoMatch.prototype.merge = function(f) {
      if (this.position === f.position) {
        return new GR.NoMatch(this.expected + " or " + f.expected, this.found, this.stream, this.position);
      } else {
        throw (this.position < f.position ? this : f);
      }
    };

    NoMatch.prototype.stackTrace = function() {
      var after, before, i;
      before = this.stream.toStringUntil(this.position);
      after = this.stream.toStringFrom(this.position);
      return "" + before + after + "\n" + (((function() {
        var j, ref, results;
        results = [];
        for (i = j = 1, ref = before.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
          results.push("-");
        }
        return results;
      })()).join("") + "^");
    };

    return NoMatch;

  })(Error);

  Id = function(x) {
    return x;
  };

  Swap = function(f) {
    return function(x, y) {
      return f(y, x);
    };
  };

  Or = function(x, y) {
    return x != null ? x : y;
  };

  Cons = function(x, y) {
    y.unshift(x);
    return y;
  };

  Opt = function(y) {
    return function(x) {
      return x != null ? x : y;
    };
  };

  Snd = function(x, y) {
    return y;
  };

  GR.Type = (function() {
    function Type(semantic) {
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    Type.prototype.parse = function(input, eof) {
      var result, s;
      if (eof == null) {
        eof = "";
      }
      assert.notInstanceOf({
        input: input
      }, GR.Stream);
      if (!(input instanceof SS.ComponentValueList)) {
        input = Parser.parse_list_of_component_values(input);
      }
      s = new GR.Stream(input, eof);
      s.optionalWhitespace();
      result = this.consume(s);
      s.optionalWhitespace();
      if (!(s.next() instanceof SS.EOFToken)) {
        s.noMatchNext("'" + eof + "'");
      }
      return result;
    };

    Type.prototype.setFs = function(fs) {
      var ref, ref1;
      this.fs = fs;
      if ((ref = this.a) != null) {
        ref.setFs(this.fs);
      }
      if ((ref1 = this.b) != null) {
        ref1.setFs(this.fs);
      }
      return this;
    };

    Type.prototype.decodejs = function() {
      throw new Error("Internal error in FunCSS: decodejs not implemented for " + this.constructor.name);
    };

    return Type;

  })();

  GR.TokenTypeTokenType = (function(superClass) {
    extend(TokenTypeTokenType, superClass);

    function TokenTypeTokenType() {
      return TokenTypeTokenType.__super__.constructor.apply(this, arguments);
    }

    TokenTypeTokenType.prototype.props = {};

    TokenTypeTokenType.prototype.consume = function(s) {
      var k, next, ref, v;
      next = s.next();
      if (next == null) {
        throw new Error("Internal Error in FunCSS: nothing returned from stream");
      }
      if (!(next instanceof this.tokenClass)) {
        s.noMatchNext(this.expected);
      }
      ref = this.props;
      for (k in ref) {
        v = ref[k];
        if (next[k] !== v) {
          s.noMatchNext(this.expected);
        }
      }
      return this.semantic(s.consume_next());
    };

    TokenTypeTokenType.prototype.semantic = function(token) {};

    return TokenTypeTokenType;

  })(GR.Type);

  GR.Keyword = (function(superClass) {
    extend(Keyword, superClass);

    Keyword.prototype.tokenClass = SS.IdentToken;

    function Keyword(value, semantic) {
      this.value = value;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.expected = "'" + this.value + "'";
      this.props = {
        value: this.value
      };
    }

    Keyword.prototype.semantic = function(token) {
      return token.value;
    };

    return Keyword;

  })(GR.TokenTypeTokenType);

  GR.Ident = (function(superClass) {
    extend(Ident, superClass);

    function Ident() {
      return Ident.__super__.constructor.apply(this, arguments);
    }

    Ident.prototype.expected = "identifier";

    Ident.prototype.tokenClass = SS.IdentToken;

    Ident.prototype.semantic = function(token) {
      return token.value;
    };

    return Ident;

  })(GR.TokenTypeTokenType);

  GR.Percentage = (function(superClass) {
    extend(Percentage, superClass);

    function Percentage() {
      return Percentage.__super__.constructor.apply(this, arguments);
    }

    Percentage.prototype.expected = "percentage";

    Percentage.prototype.tokenClass = SS.PercentageToken;

    Percentage.prototype.semantic = function(token) {
      return token.value / 100;
    };

    return Percentage;

  })(GR.TokenTypeTokenType);

  GR.Number = (function(superClass) {
    extend(Number, superClass);

    function Number() {
      return Number.__super__.constructor.apply(this, arguments);
    }

    Number.prototype.expected = "number";

    Number.prototype.tokenClass = SS.NumberToken;

    Number.prototype.semantic = function(token) {
      return token.value;
    };

    return Number;

  })(GR.TokenTypeTokenType);

  GR.Integer = (function(superClass) {
    extend(Integer, superClass);

    function Integer() {
      return Integer.__super__.constructor.apply(this, arguments);
    }

    Integer.prototype.expected = "integer";

    Integer.prototype.props = {
      type: "integer"
    };

    return Integer;

  })(GR.Number);

  GR.String = (function(superClass) {
    extend(String, superClass);

    function String() {
      return String.__super__.constructor.apply(this, arguments);
    }

    String.prototype.expected = "string";

    String.prototype.tokenClass = SS.StringToken;

    String.prototype.semantic = function(token) {
      return token.value;
    };

    return String;

  })(GR.TokenTypeTokenType);

  Whitespace = (function(superClass) {
    extend(Whitespace, superClass);

    function Whitespace() {
      return Whitespace.__super__.constructor.apply(this, arguments);
    }

    Whitespace.prototype.expected = "whitespace";

    Whitespace.prototype.tokenClass = SS.WhitespaceToken;

    return Whitespace;

  })(GR.TokenTypeTokenType);

  GR.DelimLike = (function(superClass) {
    extend(DelimLike, superClass);

    DelimLike.prototype.semantic = function() {
      return "" + this.token;
    };

    function DelimLike(token1, semantic) {
      this.token = token1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.tokenClass = this.token.constructor;
      this.expected = "'" + this.token + "'";
      if (this.token instanceof SS.DelimToken) {
        this.tokenClass = SS.DelimToken;
        this.props = {
          value: this.token.value
        };
      } else if (this.token instanceof SS.SimpleToken) {
        return;
      } else {
        throw new Error("GR.DelimLike expects a DelimToken or a SimpleToken, " + this.token.constructor.name + " got instead");
      }
    }

    return DelimLike;

  })(GR.TokenTypeTokenType);

  GR.Comma = (function(superClass) {
    extend(Comma, superClass);

    function Comma() {
      return Comma.__super__.constructor.apply(this, arguments);
    }

    Comma.prototype.expected = "','";

    Comma.prototype.tokenClass = SS.CommaToken;

    return Comma;

  })(GR.TokenTypeTokenType);

  GR.Optional = (function(superClass) {
    extend(Optional, superClass);

    function Optional(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    Optional.prototype.parse = function(input, eof) {
      var result, s;
      if (eof == null) {
        eof = "";
      }
      assert.notInstanceOf({
        input: input
      }, GR.Stream);
      if (!(input instanceof SS.ComponentValueList)) {
        input = Parser.parse_list_of_component_values(input);
      }
      s = new GR.Stream(input, eof);
      s.optionalWhitespace();
      if (s.next() instanceof SS.EOFToken) {
        return this.semantic(void 0);
      }
      result = this.semantic(this.a.consume(s));
      s.optionalWhitespace();
      if (!(s.next() instanceof SS.EOFToken)) {
        s.noMatchNext("'" + eof + "'");
      }
      return result;
    };

    Optional.prototype.consume = function(s) {
      return s.backtrack({
        "try": (function(_this) {
          return function() {
            return _this.semantic(_this.a.consume(s));
          };
        })(this),
        fallback: (function(_this) {
          return function() {
            return _this.semantic(void 0);
          };
        })(this)
      });
    };

    Optional.prototype.semantic = Id;

    return Optional;

  })(GR.Type);

  GR.Juxtaposition = (function(superClass) {
    extend(Juxtaposition, superClass);

    function Juxtaposition(a1, b, semantic) {
      this.a = a1;
      this.b = b;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    Juxtaposition.prototype.consume = function(s) {
      var x, y;
      x = this.a.consume(s);
      s.optionalWhitespace();
      y = this.b.consume(s);
      return this.semantic(x, y);
    };

    return Juxtaposition;

  })(GR.Type);

  GR.CloselyJuxtaposed = (function(superClass) {
    extend(CloselyJuxtaposed, superClass);

    function CloselyJuxtaposed(a1, b, semantic) {
      this.a = a1;
      this.b = b;
      this.semantic = semantic != null ? semantic : this.semantic;
      assert["function"]({
        semantic: this.semantic
      });
    }

    CloselyJuxtaposed.prototype.consume = function(s) {
      var x, y;
      x = this.a.consume(s);
      y = this.b.consume(s);
      return this.semantic(x, y);
    };

    return CloselyJuxtaposed;

  })(GR.Type);

  GR.ExclusiveOr = (function(superClass) {
    extend(ExclusiveOr, superClass);

    function ExclusiveOr(a1, b, semantic) {
      this.a = a1;
      this.b = b;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    ExclusiveOr.prototype.consume = function(s) {
      return s.backtrack({
        "try": (function(_this) {
          return function() {
            return _this.semantic(_this.a.consume(s));
          };
        })(this),
        fallback: (function(_this) {
          return function(e) {
            return s.backtrack({
              "try": function() {
                return _this.semantic(_this.b.consume(s));
              },
              fallback: function(f) {
                throw e.merge(f);
              }
            });
          };
        })(this)
      });
    };

    ExclusiveOr.prototype.semantic = Id;

    return ExclusiveOr;

  })(GR.Type);

  GR.And = (function(superClass) {
    extend(And, superClass);

    function And(a1, b, semantic) {
      this.a = a1;
      this.b = b;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    And.prototype.consume = function(s) {
      var res;
      res = s.backtrack({
        "try": (function(_this) {
          return function() {
            return {
              a: _this.a.consume(s)
            };
          };
        })(this),
        fallback: (function(_this) {
          return function(e) {
            return s.backtrack({
              "try": function() {
                return {
                  b: _this.b.consume(s)
                };
              },
              fallback: function(f) {
                throw e.merge(f);
              }
            });
          };
        })(this)
      });
      s.optionalWhitespace();
      if ("a" in res) {
        return this.semantic(res.a, this.b.consume(s));
      } else {
        return this.semantic(this.a.consume(s), res.b);
      }
    };

    And.prototype.semantic = Cons;

    return And;

  })(GR.Type);

  GR.InclusiveOr = (function(superClass) {
    extend(InclusiveOr, superClass);

    function InclusiveOr(a1, b, semantic) {
      this.a = a1;
      this.b = b;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    InclusiveOr.prototype.consume = function(s) {
      return new GR.ExclusiveOr(new GR.Juxtaposition(this.a, new GR.Optional(this.b), this.semantic), new GR.Juxtaposition(this.b, new GR.Optional(this.a), Swap(this.semantic))).consume(s);
    };

    InclusiveOr.prototype.semantic = Cons;

    return InclusiveOr;

  })(GR.Type);

  max = function(m, a, s) {
    if (m <= 0) {
      return [];
    }
    return s.backtrack({
      "try": (function(_this) {
        return function() {
          var head, tail;
          head = a.consume(s);
          s.optionalWhitespace();
          tail = max(m - 1, a, s);
          tail.unshift(head);
          return tail;
        };
      })(this),
      fallback: (function(_this) {
        return function(e) {
          return [];
        };
      })(this)
    });
  };

  GR.Range = (function(superClass) {
    extend(Range, superClass);

    Range.prototype.semantic = Id;

    function Range(n, m1, a1, semantic) {
      this.n = n;
      this.m = m1;
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    Range.prototype.consume = function(s) {
      var i, j, len, result, tail;
      result = [];
      i = 0;
      while (i < this.n) {
        result.push(this.a.consume(s));
        s.optionalWhitespace();
        ++i;
      }
      tail = max(this.m - this.n, this.a, s);
      for (j = 0, len = tail.length; j < len; j++) {
        i = tail[j];
        result.push(i);
      }
      return this.semantic(result);
    };

    return Range;

  })(GR.Type);

  GR.ZeroOrMore = (function(superClass) {
    extend(ZeroOrMore, superClass);

    function ZeroOrMore(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.n = 0;
      this.m = Infinity;
    }

    return ZeroOrMore;

  })(GR.Range);

  GR.OneOrMore = (function(superClass) {
    extend(OneOrMore, superClass);

    function OneOrMore(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.n = 1;
      this.m = Infinity;
    }

    return OneOrMore;

  })(GR.Range);

  GR.DelimitedBy = (function(superClass) {
    extend(DelimitedBy, superClass);

    DelimitedBy.prototype.semantic = Id;

    function DelimitedBy(delim, a1, semantic) {
      this.delim = delim;
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    DelimitedBy.prototype.consume = function(s) {
      return new GR.Juxtaposition(this.a, new GR.ZeroOrMore(new GR.Juxtaposition(this.delim, this.a, Snd)), (function(_this) {
        return function(x, y) {
          y.unshift(x);
          return _this.semantic(y);
        };
      })(this)).consume(s);
    };

    return DelimitedBy;

  })(GR.Type);

  GR.DelimitedByComma = (function(superClass) {
    extend(DelimitedByComma, superClass);

    function DelimitedByComma(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.delim = new GR.Comma;
    }

    return DelimitedByComma;

  })(GR.DelimitedBy);

  GR.AnnotationRoot = (function(superClass) {
    extend(AnnotationRoot, superClass);

    AnnotationRoot.prototype.semantic = Id;

    AnnotationRoot.prototype.hasAnnotations = false;

    function AnnotationRoot(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.prepareMappings(this.a);
    }

    AnnotationRoot.prototype.prepareMappings = function(node) {
      if (node instanceof GR.AnnotationRoot) {
        if (node instanceof GR.Annotation) {
          this.hasAnnotations = true;
          node.root = this;
        }
        return node.prepareMappings(node.a);
      } else {
        if (node.a) {
          this.prepareMappings(node.a);
        }
        if (node.b) {
          return this.prepareMappings(node.b);
        }
      }
    };

    AnnotationRoot.prototype.parseWithAnnotations = function(s) {
      var result;
      this.mappings = {};
      result = this.a.consume(s);
      return this.semantic(result, this.mappings);
    };

    AnnotationRoot.prototype.consume = function(s) {
      if (this.hasAnnotations) {
        return this.parseWithAnnotations(s);
      } else {
        return this.semantic(this.a.consume(s));
      }
    };

    return AnnotationRoot;

  })(GR.Type);

  GR.Annotation = (function(superClass) {
    extend(Annotation, superClass);

    Annotation.prototype.root = void 0;

    function Annotation(name1, a1, semantic) {
      this.name = name1;
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    Annotation.prototype.consume = function(s) {
      if (this.root) {
        return this.root.mappings[this.name] = this.hasAnnotations ? this.parseWithAnnotations(s) : this.semantic(this.a.consume(s));
      } else {
        throw new Error("GR.Annotation used without an GR.AnnotationRoot correctly configured");
      }
    };

    return Annotation;

  })(GR.AnnotationRoot);

  GR.SimpleBlock = (function(superClass) {
    extend(SimpleBlock, superClass);

    SimpleBlock.prototype.semantic = function(x) {
      return x;
    };

    function SimpleBlock(tokenClass, a1, semantic) {
      this.tokenClass = tokenClass;
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.expected = "'" + (new this.tokenClass) + "'";
    }

    SimpleBlock.prototype.consume = function(s) {
      var next;
      next = s.next();
      if (!(next instanceof SS.SimpleBlock)) {
        s.noMatchNext(this.expected);
      }
      if (!(next.token instanceof this.tokenClass)) {
        s.noMatchNext(this.expected);
      }
      s.consume_next();
      return this.semantic(this.a.parse(next.value, "" + (new ((new this.tokenClass).mirror()))));
    };

    return SimpleBlock;

  })(GR.Type);

  GR.TypeReference = (function(superClass) {
    extend(TypeReference, superClass);

    TypeReference.prototype.semantic = Id;

    function TypeReference(name1, quoted, semantic) {
      this.name = name1;
      this.quoted = quoted != null ? quoted : false;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.expected = this.name;
    }

    TypeReference.prototype.consume = function(s) {
      var type;
      if (!this.fs) {
        throw new Error("Internal error in FunCSS: fs is not set up correctly");
      }
      type = this.quoted ? this.fs.getPropertyType(this.name) : this.fs.getType(this.name);
      return type.consume(s);
    };

    return TypeReference;

  })(GR.Type);

  GR.FunctionalNotation = (function(superClass) {
    extend(FunctionalNotation, superClass);

    FunctionalNotation.prototype.semantic = Id;

    function FunctionalNotation(name1, a1, semantic) {
      this.name = name1;
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.expected = "'" + this.name + "('";
    }

    FunctionalNotation.prototype.consume = function(s) {
      var next;
      next = s.next();
      if (!(next instanceof SS.Function)) {
        s.noMatchNext(this.expected);
      }
      if (next.name !== this.name) {
        s.noMatchNext(this.expected);
      }
      s.consume_next();
      return this.semantic(this.a.parse(next.value, ")"));
    };

    return FunctionalNotation;

  })(GR.Type);

  GR.AnyFunctionalNotation = (function(superClass) {
    extend(AnyFunctionalNotation, superClass);

    AnyFunctionalNotation.prototype.expected = "function";

    AnyFunctionalNotation.prototype.semantic = function(name, x) {
      throw Error("No semantic function for GR.AnyFunctionalNotation");
    };

    function AnyFunctionalNotation(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    AnyFunctionalNotation.prototype.consume = function(s) {
      var next;
      next = s.next();
      if (!(next instanceof SS.Function)) {
        s.noMatchNext(this.expected);
      }
      s.consume_next();
      return this.semantic(next.name, this.a.parse(next.value, ")"));
    };

    return AnyFunctionalNotation;

  })(GR.Type);

  GR.RawTokens = (function(superClass) {
    extend(RawTokens, superClass);

    RawTokens.prototype.semantic = Id;

    function RawTokens(semantic) {
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    RawTokens.prototype.consume = function(s) {
      var next, result;
      result = new SS.ComponentValueList;
      next = s.next();
      while (!(next instanceof SS.EOFToken)) {
        result.push(next);
        s.consume_next();
        next = s.next();
      }
      return this.semantic(result);
    };

    return RawTokens;

  })(GR.Type);

  GR.Empty = (function(superClass) {
    extend(Empty, superClass);

    function Empty() {
      return Empty.__super__.constructor.apply(this, arguments);
    }

    Empty.prototype.semantic = function() {};

    Empty.prototype.consume = function(s) {
      return this.semantic();
    };

    return Empty;

  })(GR.Type);

  GR.Just = (function(superClass) {
    extend(Just, superClass);

    Just.prototype.semantic = Id;

    function Just(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    Just.prototype.consume = function(s) {
      return this.semantic(this.a.consume(s));
    };

    return Just;

  })(GR.Type);

}).call(this);
