// Generated by CoffeeScript 1.9.1
(function() {
  var Parser, SS, Tokenizer;

  Tokenizer = require("./tokenizer");

  SS = require("./ss_nodes");

  Parser = (function() {
    function Parser() {}

    Parser.prototype.init = function(tokens) {
      var t;
      if (typeof tokens === "string" || tokens instanceof String) {
        this.stream = Tokenizer.tokenize(tokens);
      } else {
        this.stream = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = tokens.length; i < len; i++) {
            t = tokens[i];
            results.push(t);
          }
          return results;
        })();
      }
      return this.current = void 0;
    };

    Parser.prototype.consume_next = function() {
      if (this.stream.length) {
        return this.current = this.stream.shift();
      } else {
        return this.current = new SS.EOFToken;
      }
    };

    Parser.prototype.next = function() {
      if (this.stream.length) {
        return this.stream[0];
      } else {
        return new SS.EOFToken;
      }
    };

    Parser.prototype.reconsume_current = function() {
      return this.stream.unshift(this.current);
    };

    Parser.prototype.parse_stylesheet = function(tokens) {
      this.init(tokens);
      if (typeof console.debug === "function") {
        console.debug("parsing " + tokens.slice(0, 6) + "...");
      }
      return new SS.Stylesheet(this.consume_list_of_rules(true));
    };

    Parser.prototype.parse_list_of_rules = function(tokens) {
      this.init(tokens);
      return this.consume_list_of_rules(false);
    };

    Parser.prototype.parse_rule = function(tokens) {
      var result;
      this.init(tokens);
      this.consume_next();
      while (this.current instanceof SS.WhitespaceToken) {
        this.consume_next();
      }
      if (this.current instanceof SS.EOFToken) {
        return new SS.SyntaxError;
      }
      if (this.current instanceof SS.AtKeywordToken) {
        result = this.consume_at_rule();
      } else {
        this.reconsume_current();
        result = this.consume_qualified_rule();
        if (result == null) {
          return new SS.SyntaxError;
        }
      }
      this.consume_next();
      while (this.current instanceof SS.WhitespaceToken) {
        this.consume_next();
      }
      if (this.current instanceof SS.EOFToken) {
        return result;
      }
      return new SS.SyntaxError;
    };

    Parser.prototype.parse_declaration = function(tokens) {
      var result;
      this.init(tokens);
      this.consume_next();
      while (this.current instanceof SS.WhitespaceToken) {
        this.consume_next();
      }
      if (!(this.current instanceof SS.IdentToken)) {
        return new SS.SyntaxError;
      }
      result = this.consume_a_declaration;
      if (result != null) {
        return result;
      } else {
        return new SS.SyntaxError;
      }
    };

    Parser.prototype.parse_list_of_declarations = function(tokens) {
      this.init(tokens);
      return this.consume_list_of_declarations();
    };

    Parser.prototype.parse_component_value = function(tokens) {
      var value;
      this.init(tokens);
      this.consume_next();
      while (this.current instanceof SS.WhitespaceToken) {
        this.consume_next();
      }
      if (this.current instanceof SS.EOFToken) {
        return new SS.SyntaxError;
      }
      this.reconsume_current();
      value = this.consume_component_value();
      if (value == null) {
        return new SS.SyntaxError;
      }
      this.consume_next();
      while (this.current instanceof SS.WhitespaceToken) {
        this.consume_next();
      }
      if (this.current instanceof SS.EOFToken) {
        return value;
      } else {
        return new SS.SyntaxError;
      }
    };

    Parser.prototype.parse_list_of_component_values = function(tokens) {
      var result, value;
      this.init(tokens);
      result = new SS.ComponentValueList;
      value = this.consume_component_value();
      while (!(value instanceof SS.EOFToken)) {
        result.push(value);
        value = this.consume_component_value();
      }
      return result;
    };

    Parser.prototype.consume_list_of_rules = function(toplevel) {
      var result, rule;
      result = new SS.RuleList;
      while (true) {
        this.consume_next();
        switch (false) {
          case !(this.current instanceof SS.WhitespaceToken):
            "do nothing";
            break;
          case !(this.current instanceof SS.EOFToken):
            return result;
          case !(this.current instanceof SS.CDOToken || this.current instanceof SS.CDCToken):
            if (toplevel) {

            } else {
              this.reconsume_current();
              rule = this.consume_qualified_rule();
              if (rule != null) {
                result.push(rule);
              }
            }
            break;
          case !(this.current instanceof SS.AtKeywordToken):
            rule = this.consume_at_rule();
            if (rule != null) {
              result.push(rule);
            }
            break;
          default:
            this.reconsume_current();
            rule = this.consume_qualified_rule();
            if (rule != null) {
              result.push(rule);
            }
        }
      }
    };

    Parser.prototype.consume_at_rule = function() {
      var block, name, prelude;
      name = this.current.value;
      prelude = new SS.ComponentValueList;
      while (true) {
        this.consume_next();
        switch (false) {
          case !(this.current instanceof SS.SemicolonToken || this.current instanceof SS.EOFToken):
            return new SS.AtRule(name, prelude);
          case !(this.current instanceof SS.OpeningCurlyToken):
            block = this.consume_simple_block();
            return new SS.AtRule(name, prelude, block);
          case !(this.current instanceof SS.SimpleBlock && this.current.token instanceof SS.OpeningCurlyToken):
            return new SS.AtRule(name, prelude, this.current);
          default:
            this.reconsume_current();
            prelude.push(this.consume_component_value());
        }
      }
    };

    Parser.prototype.consume_qualified_rule = function() {
      var block, prelude;
      prelude = new SS.ComponentValueList;
      while (true) {
        this.consume_next();
        switch (false) {
          case !(this.current instanceof SS.EOFToken):
            return;
          case !(this.current instanceof SS.OpeningCurlyToken):
            block = this.consume_simple_block();
            return new SS.QualifiedRule(prelude, block);
          case !(this.current instanceof SS.SimpleBlock && this.current.token instanceof SS.OpeningCurlyToken):
            return new SS.QualifiedRule(prelude, this.current);
          default:
            this.reconsume_current();
            prelude.push(this.consume_component_value());
        }
      }
    };

    Parser.prototype.consume_list_of_declarations = function() {
      var c, declaration, list, result, temp_stream;
      result = new SS.DeclarationList;
      while (true) {
        this.consume_next();
        switch (false) {
          case !(this.current instanceof SS.WhitespaceToken || this.current instanceof SS.SemicolonToken):
            "do nothing";
            break;
          case !(this.current instanceof SS.EOFToken):
            return result;
          case !(this.current instanceof SS.AtKeywordToken):
            result.push(this.consume_at_rule());
            break;
          case !(this.current instanceof SS.IdentToken):
            list = [this.current];
            this.consume_next();
            while (!(this.current instanceof SS.SemicolonToken || this.current instanceof SS.EOFToken)) {
              list.push(this.current);
              this.consume_next();
            }
            temp_stream = this.stream;
            try {
              this.stream = list;
              this.consume_next();
              declaration = this.consume_a_declaration();
            } finally {
              this.stream = temp_stream;
            }
            if (declaration != null) {
              result.push(declaration);
            }
            break;
          default:
            while ((c = this.consume_component_value()) instanceof SS.SemicolonToken || c instanceof SS.EOFToken) {
              "do nothing";
            }
        }
      }
    };

    Parser.prototype.consume_a_declaration = function() {
      var name, value;
      name = this.current.value;
      value = new SS.ComponentValueList;
      this.consume_next();
      while (this.current instanceof SS.WhitespaceToken) {
        this.consume_next();
      }
      if (!(this.current instanceof SS.ColonToken)) {
        return null;
      }
      this.consume_next();
      while (!(this.current instanceof SS.EOFToken)) {
        value.push(this.current);
        this.consume_next();
      }
      return new SS.Declaration(name, value, false);
    };

    Parser.prototype.consume_component_value = function() {
      this.consume_next();
      if (this.current instanceof SS.OpeningCurlyToken || this.current instanceof SS.OpeningSquareToken || this.current instanceof SS.OpeningParenToken) {
        return this.consume_simple_block();
      }
      if (this.current instanceof SS.FunctionToken) {
        return this.consume_function();
      }
      return this.current;
    };

    Parser.prototype.consume_simple_block = function() {
      var ending, starting, value;
      starting = this.current;
      ending = starting.mirror();
      value = new SS.ComponentValueList;
      while (true) {
        this.consume_next();
        switch (false) {
          case !(this.current instanceof SS.EOFToken || this.current instanceof ending):
            return new SS.SimpleBlock(starting, value);
          default:
            this.reconsume_current();
            value.push(this.consume_component_value());
        }
      }
    };

    Parser.prototype.consume_function = function() {
      var name, value;
      name = this.current.value;
      value = new SS.ComponentValueList;
      while (true) {
        this.consume_next();
        switch (false) {
          case !(this.current instanceof SS.EOFToken || this.current instanceof SS.ClosingParenToken):
            return new SS.Function(name, value);
          default:
            this.reconsume_current();
            value.push(this.consume_component_value());
        }
      }
    };

    return Parser;

  })();

  module.exports = new Parser;

}).call(this);
