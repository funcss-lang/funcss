// Generated by CoffeeScript 1.9.2
(function() {
  var CS, DefGrammar, Parser, SG, SS, Selectors, Semantics, Stream, TP, Vds, k, ref, v;

  Semantics = require("../semantics");

  Selectors = require("./selectors");

  Stream = require("../helpers/stream");

  TP = require("./values/tp_nodes");

  CS = require("./cascade/cs_nodes");

  Parser = require("../syntax/parser");

  Vds = require("./values/vds");

  SS = require("../syntax/ss_nodes");

  SG = require("./sg_nodes");

  DefGrammar = require("./def/def_grammar");

  debugger;

  ref = {
    insertDefinition: function(def) {
      var type, value;
      value = this.types[def.typeName].parse(def.rawValue);
      type = def.definable.makeType;
      return this.types[def.typeName] = new TP.ExclusiveOr(type, this.types[def.typeName]);
    }
  };
  for (k in ref) {
    v = ref[k];
    SG.SemanticGraph.prototype[k] = v;
  }

  exports.def = {
    handle: function(atrule, sg) {
      var def, i, len, results, s, statements;
      if (atrule.value === void 0) {
        throw new Error("block required for @def");
      }
      new TP.Full(new TP.Empty).parse(new Stream(atrule.prelude));
      statements = Parser.parse_list_of_statements(atrule.value.value);
      results = [];
      for (i = 0, len = statements.length; i < len; i++) {
        s = statements[i];
        debugger;
        def = new TP.Full(new TP.Optional(DefGrammar)).parse(new Stream(s));
        if (def != null) {
          results.push(sg.insertDefinition(def));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };

}).call(this);
