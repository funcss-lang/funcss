// Generated by CoffeeScript 1.9.2
(function() {
  var And, Annotation, AnnotationRoot, AnyFunctionalNotation, CloselyJuxtaposed, Comma, Cons, DelimLike, DelimitedBy, DelimitedByComma, Empty, Eof, ExclusiveOr, Full, FunctionalNotation, Id, Ident, InclusiveOr, Integer, Juxtaposition, Keyword, NoMatch, Number, OneOrMore, Opt, Optional, Or, Parser, Percentage, Range, RawTokens, SS, SimpleBlock, Snd, Stream, String, Swap, TokenType, Tokenizer, Type, TypeReference, UnknownType, Whitespace, ZeroOrMore, assert, max,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Tokenizer = require("../../syntax/tokenizer");

  Parser = require("../../syntax/parser");

  SS = require("../../syntax/ss_nodes");

  Stream = require("../../helpers/stream");

  assert = require("../../helpers/assert");

  NoMatch = (function(superClass) {
    extend(NoMatch, superClass);

    function NoMatch(expected, found, message) {
      this.expected = expected;
      this.found = found;
      this.name = "No match";
      this.message = message != null ? message : this.expected + " expected but " + this.found + " found";
    }

    NoMatch.prototype.toString = function() {
      return this.name + ": " + this.message;
    };

    NoMatch.prototype.merge = function(f) {
      if (this.found === f.found) {
        return new NoMatch(this.expected + " or " + f.expected, this.found);
      } else {
        return new NoMatch(this.expected + " or " + f.expected, this.found + " and " + f.found, this.message + ", " + f.message);
      }
    };

    return NoMatch;

  })(Error);

  Stream.prototype.backtrack = function(options) {
    var e, p;
    try {
      p = this.position;
      return options["try"]();
    } catch (_error) {
      e = _error;
      if (e instanceof NoMatch) {
        this.position = p;
        return options.fallback(e);
      } else {
        throw e;
      }
    }
  };

  Stream.prototype.optionalWhitespace = function() {
    var results;
    results = [];
    while (this.next() instanceof SS.WhitespaceToken) {
      results.push(this.consume_next());
    }
    return results;
  };

  Id = function(x) {
    return x;
  };

  Swap = function(f) {
    return function(x, y) {
      return f(y, x);
    };
  };

  Or = function(x, y) {
    return x != null ? x : y;
  };

  Cons = function(x, y) {
    y.unshift(x);
    return y;
  };

  Opt = function(y) {
    return function(x) {
      return x != null ? x : y;
    };
  };

  Snd = function(x, y) {
    return y;
  };

  Type = (function() {
    function Type(semantic) {
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    Type.prototype.setSg = function(sg) {
      var ref, ref1;
      this.sg = sg;
      if ((ref = this.a) != null) {
        ref.setSg(this.sg);
      }
      return (ref1 = this.b) != null ? ref1.setSg(this.sg) : void 0;
    };

    return Type;

  })();

  TokenType = (function(superClass) {
    extend(TokenType, superClass);

    function TokenType() {
      return TokenType.__super__.constructor.apply(this, arguments);
    }

    TokenType.prototype.props = {};

    TokenType.prototype.parse = function(s) {
      var k, next, ref, v;
      next = s.next();
      if (!(next instanceof this.tokenClass)) {
        throw new NoMatch(this.expected, "'" + next + "'");
      }
      ref = this.props;
      for (k in ref) {
        v = ref[k];
        if (next[k] !== v) {
          throw new NoMatch(this.expected, "'" + next + "'");
        }
      }
      return this.semantic(s.consume_next());
    };

    TokenType.prototype.semantic = function(token) {};

    return TokenType;

  })(Type);

  Keyword = (function(superClass) {
    extend(Keyword, superClass);

    Keyword.prototype.tokenClass = SS.IdentToken;

    function Keyword(value, semantic) {
      this.value = value;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.expected = "'" + this.value + "'";
      this.props = {
        value: this.value
      };
    }

    Keyword.prototype.semantic = function(token) {
      return token.value;
    };

    return Keyword;

  })(TokenType);

  Ident = (function(superClass) {
    extend(Ident, superClass);

    function Ident() {
      return Ident.__super__.constructor.apply(this, arguments);
    }

    Ident.prototype.expected = "identifier";

    Ident.prototype.tokenClass = SS.IdentToken;

    Ident.prototype.semantic = function(token) {
      return token.value;
    };

    return Ident;

  })(TokenType);

  Percentage = (function(superClass) {
    extend(Percentage, superClass);

    function Percentage() {
      return Percentage.__super__.constructor.apply(this, arguments);
    }

    Percentage.prototype.expected = "percentage";

    Percentage.prototype.tokenClass = SS.PercentageToken;

    Percentage.prototype.semantic = function(token) {
      return token.value / 100;
    };

    return Percentage;

  })(TokenType);

  Number = (function(superClass) {
    extend(Number, superClass);

    function Number() {
      return Number.__super__.constructor.apply(this, arguments);
    }

    Number.prototype.expected = "number";

    Number.prototype.tokenClass = SS.NumberToken;

    Number.prototype.semantic = function(token) {
      return token.value;
    };

    return Number;

  })(TokenType);

  Integer = (function(superClass) {
    extend(Integer, superClass);

    function Integer() {
      return Integer.__super__.constructor.apply(this, arguments);
    }

    Integer.prototype.expected = "integer";

    Integer.prototype.props = {
      type: "integer"
    };

    return Integer;

  })(Number);

  String = (function(superClass) {
    extend(String, superClass);

    function String() {
      return String.__super__.constructor.apply(this, arguments);
    }

    String.prototype.expected = "string";

    String.prototype.tokenClass = SS.StringToken;

    String.prototype.semantic = function(token) {
      return token.value;
    };

    return String;

  })(TokenType);

  Whitespace = (function(superClass) {
    extend(Whitespace, superClass);

    function Whitespace() {
      return Whitespace.__super__.constructor.apply(this, arguments);
    }

    Whitespace.prototype.expected = "whitespace";

    Whitespace.prototype.tokenClass = SS.WhitespaceToken;

    return Whitespace;

  })(TokenType);

  DelimLike = (function(superClass) {
    extend(DelimLike, superClass);

    DelimLike.prototype.semantic = function() {
      return "" + this.token;
    };

    function DelimLike(token1, semantic) {
      this.token = token1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.tokenClass = this.token.constructor;
      this.expected = "'" + this.token + "'";
      if (this.token instanceof SS.DelimToken) {
        this.tokenClass = SS.DelimToken;
        this.props = {
          value: this.token.value
        };
      } else if (this.token instanceof SS.SimpleToken) {
        return;
      } else {
        throw new Error("DelimLike expects a DelimToken or a SimpleToken, " + this.token.constructor.name + " got instead");
      }
    }

    return DelimLike;

  })(TokenType);

  Comma = (function(superClass) {
    extend(Comma, superClass);

    function Comma() {
      return Comma.__super__.constructor.apply(this, arguments);
    }

    Comma.prototype.expected = "','";

    Comma.prototype.tokenClass = SS.CommaToken;

    return Comma;

  })(TokenType);

  Optional = (function(superClass) {
    extend(Optional, superClass);

    function Optional(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    Optional.prototype.parse = function(s) {
      return s.backtrack({
        "try": (function(_this) {
          return function() {
            return _this.semantic(_this.a.parse(s));
          };
        })(this),
        fallback: (function(_this) {
          return function() {
            return _this.semantic(void 0);
          };
        })(this)
      });
    };

    Optional.prototype.semantic = Id;

    return Optional;

  })(Type);

  Juxtaposition = (function(superClass) {
    extend(Juxtaposition, superClass);

    function Juxtaposition(a1, b, semantic) {
      this.a = a1;
      this.b = b;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    Juxtaposition.prototype.parse = function(s) {
      var x, y;
      x = this.a.parse(s);
      s.optionalWhitespace();
      y = this.b.parse(s);
      return this.semantic(x, y);
    };

    return Juxtaposition;

  })(Type);

  CloselyJuxtaposed = (function(superClass) {
    extend(CloselyJuxtaposed, superClass);

    function CloselyJuxtaposed(a1, b, semantic) {
      this.a = a1;
      this.b = b;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    CloselyJuxtaposed.prototype.parse = function(s) {
      var x, y;
      x = this.a.parse(s);
      y = this.b.parse(s);
      return this.semantic(x, y);
    };

    return CloselyJuxtaposed;

  })(Type);

  ExclusiveOr = (function(superClass) {
    extend(ExclusiveOr, superClass);

    function ExclusiveOr(a1, b, semantic) {
      this.a = a1;
      this.b = b;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    ExclusiveOr.prototype.parse = function(s) {
      return s.backtrack({
        "try": (function(_this) {
          return function() {
            return _this.semantic(_this.a.parse(s));
          };
        })(this),
        fallback: (function(_this) {
          return function(e) {
            return s.backtrack({
              "try": function() {
                return _this.semantic(_this.b.parse(s));
              },
              fallback: function(f) {
                throw e.merge(f);
              }
            });
          };
        })(this)
      });
    };

    ExclusiveOr.prototype.semantic = Id;

    return ExclusiveOr;

  })(Type);

  And = (function(superClass) {
    extend(And, superClass);

    function And(a1, b, semantic) {
      this.a = a1;
      this.b = b;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    And.prototype.parse = function(s) {
      var res;
      res = s.backtrack({
        "try": (function(_this) {
          return function() {
            return {
              a: _this.a.parse(s)
            };
          };
        })(this),
        fallback: (function(_this) {
          return function(e) {
            return s.backtrack({
              "try": function() {
                return {
                  b: _this.b.parse(s)
                };
              },
              fallback: function(f) {
                throw e.merge(f);
              }
            });
          };
        })(this)
      });
      s.optionalWhitespace();
      if ("a" in res) {
        return this.semantic(res.a, this.b.parse(s));
      } else {
        return this.semantic(this.a.parse(s), res.b);
      }
    };

    And.prototype.semantic = Cons;

    return And;

  })(Type);

  InclusiveOr = (function(superClass) {
    extend(InclusiveOr, superClass);

    function InclusiveOr(a1, b, semantic) {
      this.a = a1;
      this.b = b;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    InclusiveOr.prototype.parse = function(s) {
      return new ExclusiveOr(new Juxtaposition(this.a, new Optional(this.b), this.semantic), new Juxtaposition(this.b, new Optional(this.a), Swap(this.semantic))).parse(s);
    };

    InclusiveOr.prototype.semantic = Cons;

    return InclusiveOr;

  })(Type);

  max = function(m, a, s) {
    if (m <= 0) {
      return [];
    }
    return s.backtrack({
      "try": (function(_this) {
        return function() {
          var head, tail;
          head = a.parse(s);
          s.optionalWhitespace();
          tail = max(m - 1, a, s);
          tail.unshift(head);
          return tail;
        };
      })(this),
      fallback: (function(_this) {
        return function(e) {
          return [];
        };
      })(this)
    });
  };

  Range = (function(superClass) {
    extend(Range, superClass);

    Range.prototype.semantic = Id;

    function Range(n, m1, a1, semantic) {
      this.n = n;
      this.m = m1;
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    Range.prototype.parse = function(s) {
      var i, j, len, result, tail;
      result = [];
      i = 0;
      while (i < this.n) {
        result.push(this.a.parse(s));
        s.optionalWhitespace();
        ++i;
      }
      tail = max(this.m - this.n, this.a, s);
      for (j = 0, len = tail.length; j < len; j++) {
        i = tail[j];
        result.push(i);
      }
      return this.semantic(result);
    };

    return Range;

  })(Type);

  ZeroOrMore = (function(superClass) {
    extend(ZeroOrMore, superClass);

    function ZeroOrMore(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.n = 0;
      this.m = Infinity;
    }

    return ZeroOrMore;

  })(Range);

  OneOrMore = (function(superClass) {
    extend(OneOrMore, superClass);

    function OneOrMore(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.n = 1;
      this.m = Infinity;
    }

    return OneOrMore;

  })(Range);

  DelimitedBy = (function(superClass) {
    extend(DelimitedBy, superClass);

    DelimitedBy.prototype.semantic = Id;

    function DelimitedBy(delim, a1, semantic) {
      this.delim = delim;
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    DelimitedBy.prototype.parse = function(s) {
      return new Juxtaposition(this.a, new ZeroOrMore(new Juxtaposition(this.delim, this.a, Snd)), (function(_this) {
        return function(x, y) {
          y.unshift(x);
          return _this.semantic(y);
        };
      })(this)).parse(s);
    };

    return DelimitedBy;

  })(Type);

  DelimitedByComma = (function(superClass) {
    extend(DelimitedByComma, superClass);

    function DelimitedByComma(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.delim = new Comma;
    }

    return DelimitedByComma;

  })(DelimitedBy);

  Eof = (function(superClass) {
    extend(Eof, superClass);

    function Eof() {
      return Eof.__super__.constructor.apply(this, arguments);
    }

    Eof.prototype.expected = "EOF";

    Eof.prototype.tokenClass = SS.EOFToken;

    return Eof;

  })(TokenType);

  Full = (function(superClass) {
    extend(Full, superClass);

    Full.prototype.semantic = function(x) {
      return x;
    };

    function Full(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
      assert.hasProp({
        a: this.a
      }, "parse");
    }

    Full.prototype.parse = function(s) {
      var result;
      s.optionalWhitespace();
      result = this.a.parse(s);
      s.optionalWhitespace();
      new Eof().parse(s);
      return this.semantic(result);
    };

    return Full;

  })(Type);

  AnnotationRoot = (function(superClass) {
    extend(AnnotationRoot, superClass);

    AnnotationRoot.prototype.semantic = Id;

    AnnotationRoot.prototype.hasAnnotations = false;

    function AnnotationRoot(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.prepareMappings(this.a);
    }

    AnnotationRoot.prototype.prepareMappings = function(node) {
      if (node instanceof AnnotationRoot) {
        if (node instanceof Annotation) {
          this.hasAnnotations = true;
          node.root = this;
        }
        return node.prepareMappings(node.a);
      } else {
        if (node.a) {
          this.prepareMappings(node.a);
        }
        if (node.b) {
          return this.prepareMappings(node.b);
        }
      }
    };

    AnnotationRoot.prototype.parseWithAnnotations = function(s) {
      var result;
      this.mappings = {};
      result = this.a.parse(s);
      return this.semantic(result, this.mappings);
    };

    AnnotationRoot.prototype.parse = function(s) {
      if (this.hasAnnotations) {
        return this.parseWithAnnotations(s);
      } else {
        return this.semantic(this.a.parse(s));
      }
    };

    return AnnotationRoot;

  })(Type);

  Annotation = (function(superClass) {
    extend(Annotation, superClass);

    Annotation.prototype.root = void 0;

    function Annotation(name1, a1, semantic) {
      this.name = name1;
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    Annotation.prototype.parse = function(s) {
      if (this.root) {
        return this.root.mappings[this.name] = this.hasAnnotations ? this.parseWithAnnotations(s) : this.semantic(this.a.parse(s));
      } else {
        throw new Error("Annotation used without an AnnotationRoot correctly configured");
      }
    };

    return Annotation;

  })(AnnotationRoot);

  SimpleBlock = (function(superClass) {
    extend(SimpleBlock, superClass);

    SimpleBlock.prototype.semantic = function(x) {
      return x;
    };

    function SimpleBlock(tokenClass, a1, semantic) {
      this.tokenClass = tokenClass;
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.expected = "'" + (new this.tokenClass) + "'";
    }

    SimpleBlock.prototype.parse = function(s) {
      var next;
      next = s.next();
      if (!(next instanceof SS.SimpleBlock)) {
        throw new NoMatch(this.expected, "'" + next + "'");
      }
      if (!(next.token instanceof this.tokenClass)) {
        throw new NoMatch(this.expected, "'" + next + "'");
      }
      s.consume_next();
      return this.semantic(new Full(this.a).parse(new Stream(next.value)));
    };

    return SimpleBlock;

  })(Type);

  TypeReference = (function(superClass) {
    extend(TypeReference, superClass);

    TypeReference.prototype.semantic = Id;

    function TypeReference(name1, quoted, semantic) {
      this.name = name1;
      this.quoted = quoted != null ? quoted : false;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.expected = this.name;
    }

    TypeReference.prototype.parse = function(s) {
      var type;
      if (!this.sg) {
        throw new Error("sg is not set up correctly");
      }
      type = this.quoted ? this.sg.getQuotedType(this.name) : this.sg.getType(this.name);
      if (type == null) {
        throw new UnknownType(this.name, this.quoted);
      }
      return type.parse(s);
    };

    return TypeReference;

  })(Type);

  UnknownType = (function(superClass) {
    extend(UnknownType, superClass);

    function UnknownType(type1, quoted) {
      this.type = type1;
      this.quoted = quoted;
      this.message = this.quoted ? "unknown type <'" + this.type + "'>" : "unknown type <" + this.type + ">";
    }

    return UnknownType;

  })(Error);

  FunctionalNotation = (function(superClass) {
    extend(FunctionalNotation, superClass);

    FunctionalNotation.prototype.semantic = Id;

    function FunctionalNotation(name1, a1, semantic) {
      this.name = name1;
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
      this.expected = "'" + this.name + "('";
    }

    FunctionalNotation.prototype.parse = function(s) {
      var next;
      next = s.next();
      if (!(next instanceof SS.Function)) {
        throw new NoMatch(this.expected, "'" + next + "'");
      }
      if (next.name !== this.name) {
        throw new NoMatch(this.expected, "'" + next + "'");
      }
      s.consume_next();
      return this.semantic(new Full(this.a).parse(new Stream(next.value)));
    };

    return FunctionalNotation;

  })(Type);

  AnyFunctionalNotation = (function(superClass) {
    extend(AnyFunctionalNotation, superClass);

    AnyFunctionalNotation.prototype.expected = "function";

    AnyFunctionalNotation.prototype.semantic = function(name, x) {
      throw Error("No semantic function for AnyFunctionalNotation");
    };

    function AnyFunctionalNotation(a1, semantic) {
      this.a = a1;
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    AnyFunctionalNotation.prototype.parse = function(s) {
      var next;
      next = s.next();
      if (!(next instanceof SS.Function)) {
        throw new NoMatch(this.expected, "'" + next + "'");
      }
      s.consume_next();
      return this.semantic(next.name, new Full(this.a).parse(new Stream(next.value)));
    };

    return AnyFunctionalNotation;

  })(Type);

  RawTokens = (function(superClass) {
    extend(RawTokens, superClass);

    RawTokens.prototype.semantic = Id;

    function RawTokens(semantic) {
      this.semantic = semantic != null ? semantic : this.semantic;
    }

    RawTokens.prototype.parse = function(s) {
      var next, result;
      result = new SS.ComponentValueList;
      next = s.consume_next();
      while (!(next instanceof SS.EOFToken)) {
        result.push(next);
        next = s.consume_next();
      }
      return this.semantic(result);
    };

    return RawTokens;

  })(Type);

  Empty = (function(superClass) {
    extend(Empty, superClass);

    function Empty() {
      return Empty.__super__.constructor.apply(this, arguments);
    }

    Empty.prototype.parse = function(s) {};

    return Empty;

  })(Type);

  module.exports = {
    Type: Type,
    TokenType: TokenType,
    Keyword: Keyword,
    DelimLike: DelimLike,
    Ident: Ident,
    Integer: Integer,
    Number: Number,
    Percentage: Percentage,
    Comma: Comma,
    String: String,
    NoMatch: NoMatch,
    Juxtaposition: Juxtaposition,
    CloselyJuxtaposed: CloselyJuxtaposed,
    And: And,
    ExclusiveOr: ExclusiveOr,
    InclusiveOr: InclusiveOr,
    Optional: Optional,
    OneOrMore: OneOrMore,
    ZeroOrMore: ZeroOrMore,
    Range: Range,
    DelimitedByComma: DelimitedByComma,
    Eof: Eof,
    Full: Full,
    DelimitedBy: DelimitedBy,
    Annotation: Annotation,
    AnnotationRoot: AnnotationRoot,
    SimpleBlock: SimpleBlock,
    TypeReference: TypeReference,
    UnknownType: UnknownType,
    FunctionalNotation: FunctionalNotation,
    AnyFunctionalNotation: AnyFunctionalNotation,
    RawTokens: RawTokens,
    Empty: Empty
  };

}).call(this);
