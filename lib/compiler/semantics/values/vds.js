// Generated by CoffeeScript 1.9.2
(function() {
  var AddMarkings, Ampersand, And, Annotation, Asterisk, Atom, Bar, Bracket, Bracketable, Bracketed, ClosingAngle, ClosingCurly, ClosingSquare, Colon, Column, Combined, Comma, ComponentValue, Cons, DblAmpersand, Dollar, ExclusiveOr, Fst, FunctionalNotation, Hashmark, Id, Ident, InclusiveOr, Integer, Juxtaposition, Keyword, LiteralComma, LiteralSlash, Multipliable, Multiplied, Multiplier, Number, OpeningAngle, OpeningCurly, OpeningSquare, PLACEHOLDER, Pair, Percentage, Plus, QuestionMark, RepeatCount, SS, Snd, String, TP, TYPES, TypeReference, VL, Variable, isEmptyObject, k, pairsOf, ref, v,
    slice = [].slice;

  TP = require("./tp_nodes");

  SS = require("../../syntax/ss_nodes");

  VL = require("./vl_nodes");

  TYPES = {};

  Id = Fst = function(x) {
    return x;
  };

  Snd = function(_, y) {
    return y;
  };

  Pair = function(x, y) {
    return [x, y];
  };

  Cons = function(x, y) {
    y.unshift(x);
    return y;
  };

  pairsOf = function(t, list, opts) {
    if (opts == null) {
      opts = {};
    }
    if (!list.length) {
      throw new Error("internal error in VDS: cannot make pairs of empty list or a non-list");
    }
    if (list.length === 1) {
      return list[0];
    }
    if (list.length === 2) {
      return new t(list[0], list[1], opts.pair);
    }
    return new t(list[0], pairsOf(t, list.slice(1), opts), opts.cons);
  };

  OpeningAngle = new TP.DelimLike(new SS.DelimToken('<'));

  ClosingAngle = new TP.DelimLike(new SS.DelimToken('>'));

  OpeningCurly = new TP.DelimLike(new SS.OpeningCurlyToken);

  ClosingCurly = new TP.DelimLike(new SS.ClosingCurlyToken);

  OpeningSquare = new TP.DelimLike(new SS.OpeningSquareToken);

  ClosingSquare = new TP.DelimLike(new SS.ClosingSquareToken);

  Colon = new TP.DelimLike(new SS.ColonToken);

  Ampersand = new TP.DelimLike(new SS.DelimToken('&'));

  DblAmpersand = new TP.CloselyJuxtaposed(Ampersand, Ampersand, function() {});

  Column = new TP.DelimLike(new SS.ColumnToken);

  Bar = new TP.DelimLike(new SS.DelimToken('|'));

  Comma = new TP.DelimLike(new SS.CommaToken);

  Dollar = new TP.DelimLike(new SS.DelimToken('$'));

  PLACEHOLDER = {
    parse: function() {
      throw new Error("PLACEHOLDER not replaced");
    }
  };

  Ident = new TP.Ident;

  Number = new TP.Number;

  Integer = new TP.Integer;

  Percentage = new TP.Percentage;

  String = new TP.String;

  AddMarkings = function(x, markings) {
    if (markings && !isEmptyObject(markings)) {
      return new VL.Marking(x, markings);
    } else {
      return x;
    }
  };

  LiteralSlash = new TP.DelimLike(new SS.DelimToken('/'), function(x) {
    return new TP.DelimLike(x, function(x) {
      return new VL.Keyword("/");
    });
  });

  LiteralComma = new TP.DelimLike(new SS.CommaToken, function(x) {
    return new TP.DelimLike(x, function(x) {
      return new VL.Keyword(",");
    });
  });

  Hashmark = new TP.DelimLike(new SS.DelimToken('#'), function() {
    return {
      collection: VL.CommaDelimitedCollection,
      multiplier: TP.DelimitedByComma
    };
  });

  Plus = new TP.DelimLike(new SS.DelimToken('+'), function() {
    return {
      collection: VL.Collection,
      multiplier: TP.OneOrMore
    };
  });

  QuestionMark = new TP.DelimLike(new SS.DelimToken('?'), function() {
    return {
      collection: false,
      multiplier: TP.Optional
    };
  });

  Asterisk = new TP.DelimLike(new SS.DelimToken('*'), function() {
    return {
      collection: VL.Collection,
      multiplier: TP.ZeroOrMore
    };
  });

  RepeatCount = new TP.SimpleBlock(SS.OpeningCurlyToken, new TP.CloselyJuxtaposed(Integer, new TP.CloselyJuxtaposed(Comma, Integer, Snd), Pair), function(arg) {
    var from, to;
    from = arg[0], to = arg[1];
    return {
      collection: VL.Collection,
      multiplier: TP.Range,
      args: [from, to]
    };
  });

  Keyword = new TP.Ident(function(x) {
    return new TP.Keyword(x.value, function(x) {
      return new VL.Keyword(x.value);
    });
  });

  TypeReference = new TP.Juxtaposition(OpeningAngle, new TP.Juxtaposition(new TP.ExclusiveOr(new TP.Ident(function(x) {
    return [x.value, false];
  }), new TP.String(function(x) {
    return [x.value, true];
  })), ClosingAngle, Fst), function(_, arg) {
    var name, quoted;
    name = arg[0], quoted = arg[1];
    return new TP.TypeReference(name, quoted);
  });

  FunctionalNotation = new TP.AnyFunctionalNotation(PLACEHOLDER, function(name, x) {
    return new TP.FunctionalNotation(name, x, function(y) {
      return new VL.FunctionalNotation(name, y);
    });
  });

  Variable = new TP.ExclusiveOr(new TP.CloselyJuxtaposed(Dollar, Ident, function(x, y) {
    return x + y;
  }), Ident);

  Variable.expected = "variable";

  Annotation = new TP.Juxtaposition(Variable, new TP.Juxtaposition(Colon, new TP.ExclusiveOr(new TP.Ident(function(x) {
    return new TP.TypeReference(x.value);
  }), PLACEHOLDER), Snd), function(name, a) {
    return new TP.Annotation(name, a, AddMarkings);
  });

  ComponentValue = pairsOf(TP.ExclusiveOr, [TypeReference, Annotation, Keyword, FunctionalNotation, LiteralSlash, LiteralComma]);

  Bracketable = ComponentValue;

  Bracket = new TP.SimpleBlock(SS.OpeningSquareToken, PLACEHOLDER);

  Bracketed = new TP.ExclusiveOr(Bracketable, Bracket);

  Annotation.b.b.b = Bracket;

  Multipliable = Bracketed;

  Multiplier = pairsOf(TP.ExclusiveOr, [Asterisk, Plus, QuestionMark, RepeatCount, Hashmark], {
    pair: Id,
    cons: Id
  });

  Multiplied = new TP.Juxtaposition(Multipliable, new TP.Optional(Multiplier), function(a, multdata) {
    var ref, ref1;
    if (multdata) {
      if (multdata.collection) {
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(multdata.multiplier, slice.call((ref = multdata.args) != null ? ref : []).concat([new TP.AnnotationRoot(a, AddMarkings)], [function(arr) {
          return new multdata.collection(arr);
        }]), function(){});
      } else {
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(multdata.multiplier, slice.call((ref1 = multdata.args) != null ? ref1 : []).concat([new TP.AnnotationRoot(a, AddMarkings)], [function(x) {
          return x != null ? x : new VL.EmptyValue;
        }]), function(){});
      }
    } else {
      return a;
    }
  });

  isEmptyObject = function(x) {
    var k;
    for (k in x) {
      if (x.hasOwnProperty(k)) {
        return false;
      }
    }
    return true;
  };

  Juxtaposition = new TP.OneOrMore(Multiplied, function(l) {
    return pairsOf(TP.Juxtaposition, l, {
      pair: function(x, y) {
        return new VL.Juxtaposition([x, y]);
      },
      cons: Cons
    });
  });

  And = new TP.DelimitedBy(DblAmpersand, Juxtaposition, function(l) {
    return pairsOf(TP.And, l, {
      pair: function(x, y) {
        return new VL.And([x, y]);
      },
      cons: Cons
    });
  });

  InclusiveOr = new TP.DelimitedBy(Column, And, function(l) {
    return pairsOf(TP.InclusiveOr, l, {
      pair: function(x, y) {
        return new VL.InclusiveOr([x != null ? x : new VL.EmptyValue, y != null ? y : new VL.EmptyValue]);
      },
      cons: function(x, y) {
        y.unshift(x != null ? x : new VL.EmptyValue);
        return y;
      }
    });
  });

  ExclusiveOr = new TP.DelimitedBy(Bar, InclusiveOr, function(l) {
    return pairsOf(TP.ExclusiveOr, l, {
      pair: Id,
      cons: Id
    });
  });

  Combined = ExclusiveOr;

  Bracket.a = Combined;

  FunctionalNotation.a = Combined;

  module.exports = new TP.Full(Combined, function(x) {
    return new TP.AnnotationRoot(x, AddMarkings);
  });

  TYPES.ident = new TP.Ident(function(x) {
    return new VL.Keyword(x.value);
  });

  TYPES.number = new TP.Number(function(x) {
    return new VL.Number(x.value);
  });

  TYPES.integer = new TP.Integer(function(x) {
    return new VL.Number(x.value);
  });

  TYPES.percentage = new TP.Percentage(function(x) {
    return new VL.Percentage(x.value);
  });

  TYPES.string = new TP.String(function(x) {
    return new VL.String(x.value);
  });

  Atom = Bracketed;

  ref = {
    TYPES: TYPES,
    Atom: Atom,
    TypeReference: TypeReference
  };
  for (k in ref) {
    v = ref[k];
    module.exports[k] = v;
  }

}).call(this);
